* Brain
These are my configurations needed to work with my main notes and agendas. These files contain sensitive data so I don't include them on every computer.

#+begin_src elisp :noweb-ref configs
(defun find-place () (interactive)
        (let* ((candidates (org-map-entries
                            '(s-join "/" (org-get-outline-path t)) nil
                            `(,(f-join org-directory "other/places.org")))))

        (org-ql-search 'org-agenda-files
            `(children (property "Place" ,(completing-read "Places: " candidates))) :super-groups '((:auto-category t)))))


(defun ccc/find-areas ()
    (read-file-name "Areas: " "~/roam/areas/" nil (confirm-nonexistent-file-or-buffer) nil #'f-file-p))

(defun org-dblock-write:contacts (params)
(org-dblock-write:org-ql `(:file ,(f-join org-directory "other/contacts.org")
                            :columns (heading todo ((property "Place") "Place"))
                            :query (children (and (heading "Services") (children (heading ,(plist-get params :service))))))))

(map! :leader
    :prefix ("o f" . "Find")
    "a" (cmd! (find-file (ccc/find-areas)))
    "p" #'find-place)
#+end_src

#+begin_src elisp :noweb-ref packages
(package! emacsql-sqlite3)
#+end_src

Capture Templates

#+begin_src elisp :noweb-ref capture-templates
("Task" :keys "t" :file (lambda () (ccc/find-areas)) :olp ("Tasks") :template "* TODO %?")
("Event" :keys "e" :file (lambda () (ccc/find-areas)) :olp ("Events") :template-file ,(f-join dotfiles-directory "templates" "org" "event.org"))
("Art" :keys "a" :file ,(f-join org-directory "areas/art.org") :id "23909e75-68b8-44ff-a26a-6dab908122c0" :template-file ,(f-join dotfiles-directory "templates" "org" "art.org"))

#+end_src

** Search
*** Deft

I use [[https://jblevins.org/projects/deft/][Deft]] to search my org files using general text serach

#+begin_src elisp :noweb-ref configs
(setq deft-directory (f-join org-directory "notes"))
#+end_src

** org-ql
#+begin_src elisp :noweb-ref configs
(setq org-ql-views '(("Visions"
                     :buffers-files org-agenda-files
                     :query (tags-local "vision")
                     :super-groups ((:auto-category)))
                     ("Rules"
                     :buffers-files org-agenda-files
                     :query (tags-local "rule")
                     :super-groups ((:auto-category)))
                    ("Fitness"
                     :buffers-files org-agenda-files
                     :query (and (category "Fitness") (tags "goal") (todo "PROGRESS") (parent (tags "progression")))
                     :super-groups ((:auto-parent))
                     )
                    ("Progressions"
                     :buffers-files org-agenda-files
                     :query (and (tags-local "progression") (todo "PROGRESS") )
                     :super-groups ((:auto-parent))
                     )
                    ("Recipes"
                     :buffers-files org-agenda-files
                     :query (tags-local "recipe")
                     :super-groups ((:auto-category)))
                    ("Maintenance"
                     :buffers-files org-agenda-files
                     :query (and (tags "maintenance") (not (tags "ARCHIVE")) (todo))
                     :super-groups ((:auto-category)))
                    ("Work Queue"
                     :buffers-files org-agenda-files
                     :query (and
                             (not (scheduled))
                             (not (todo "WISH" "SHIPPING"))
                             (not (tags "ARCHIVE" "recipe" "certification" "book" "goal" "vision" "training" "progression"))
                             (not (path "contacts.org"))
                             (todo))
                     :sort priority
                     :super-groups ((:name "In Progress" :todo "PROGRESS")
                                    (:name "Waiting" :todo "WAITING")
                                    (:priority "A")
                                    (:auto-category)))
                    ("Wishlist"
                     :buffers-files org-agenda-files
                     :query (todo "WISH" "SHIPPING")
                     :sort priority
                     :super-groups ((:name "In Progress" :todo "SHIPPING")
                                       (:auto-category)))
                       ("Owned"
                        :buffers-files org-agenda-files
                        :query (or (and (tags-local "owned") (not (tags-local "book"))) (todo "OWNED"))
                        :sort priority
                        :super-groups ((:auto-category)))
                       ("Consumables"
                        :buffers-files org-agenda-files
                        :query (tags-local "consumable")
                        :sort priority
                        :super-groups ((:auto-category)))
                       ("Goals"
                        :buffers-files org-agenda-files
                        :query (tags-local "goal")
                        :super-groups ((:name "In Progress" :todo "PROGRESS")
                                       (:auto-category)))
                       ("Goals - In Progress"
                        :buffers-files org-agenda-files
                        :query (and (todo "PROGRESS") (tags-local "goal"))
                        :super-groups ((:auto-category)))
                       ("Training"
                        :buffers-files org-agenda-files
                        :query (tags-local "training")
                        :super-groups ((:auto-category)))
                       ("Books"
                        :buffers-files org-agenda-files
                        :query (tags-local "book")
                        :sort (priority todo)
                        :super-groups ((:name "In Progress" :todo "PROGRESS")
                                       (:priority "A")
                                       (:auto-category)))
                       ("Certifications"
                        :buffers-files org-agenda-files
                        :query (tags-local "certification")
                        :super-groups ((:name "In Progress" :todo "PROGRESS")
                                       (:name "Done" :todo "DONE")
                                       (:auto-category)))  ))
#+end_src

** Flash Cards

#+begin_src elisp :noweb-ref configs
(map!
   (:leader
    :prefix ("o o D" . "Drills")
     "d" #'org-drill
     "t" #'org-drill-tree
     "r" #'org-drill-resume
     "c" #'org-drill-cram
    ))

(require 'org-drill)

(setq org-drill-maximum-items-per-session 40)
#+end_src

#+begin_src elisp :noweb-ref packages
(package! org-drill)
#+end_src

#+begin_src elisp :noweb-ref bookmarks
("drills"
  (filename . "~/roam/other/drills.org"))
("bookmarks"
  (filename . "~/roam/other/bookmarks.org"))
("contacts"
  (filename . "~/roam/other/contacts.org"))
("places"
  (filename . "~/roam/other/places.org"))
("books"
  (filename . "~/roam/books/books.bib"))
#+end_src
#+end_src
** Roam
:PROPERTIES:
:ID:       c94f5761-3a42-44df-afd3-55f409902dbf
:END:

[[https://www.orgroam.com/][org-roam]] applies the [[https://zettelkasten.de/posts/overview/][Zettelkasten Method]] to Emacs and Org mode. The idea is that you have many small note files with no strict structure, that link use hyperlinks to relate to each other. Org-roam helps in this by keeping track of the *backlinks* so you can easily see which notes link to the note that you're currently looking at.

#+begin_src elisp :noweb-ref configs :results none
(defun ccc/roam-filter (node)
  (let ((path (org-roam-node-file node)))
    (not (file-in-directory-p path (f-join org-roam-directory "areas")))))

(setq org-roam-tag-sources '(prop last-directory)
      org-roam-file-exclude-regexp "other/.*"
      org-roam-capture-templates '(("d" "default" plain "%?"
                                    :target (file+head "notes/%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n\n- tags :: ")
                                    :unnarrowed t)
                                   ("c" "conference" plain "%?"
                                    :target "conferences/%<%Y%m%d%H%M%S>-${slug}"
                                    :head "* ${title}\n\n- tags :: "
                                    :unnarrowed t)
                                   ("s" "Store" plain "%?"
                                    :target (file+head "stores/%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n\n- tags :: ")
                                    :unnarrowed t)
                                   ("r" "Recipe" plain "%?"
                                    :target (file+head "recipes/%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n\n- tags :: ")
                                    :unnarrowed t)
                                   ("R" "Resource" plain "%?"
                                    :target (file+head "notes/resources/%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n\n- tags :: ")
                                    :unnarrowed t)
                                   ("P" "Presentation" plain "%?"
                                    :target "presentations/%<%Y%m%d%H%M%S>-${slug}"
                                    :head "#+title: ${title}\n\n- tags :: "
                                    :unnarrowed t)
                                   ("p" "Programming Language" plain
                                    (file "~/roam/areas/software/templates/programming_language.org")
                                    :target "notes/%<%Y%m%d%H%M%S>-${slug}"))
      )

(map! :leader
      :n "n r f" (cmd! (org-roam-node-find nil nil #'ccc/roam-filter)))

(defvar embark-org-roam-map (make-sparse-keymap))

(map! :map embark-org-roam-map
      :desc "Open in other window" "o" (cmd!! #'org-roam-node-find '(4))
      )

(add-to-list 'embark-keymap-alist '(org-roam-node embark-org-roam-map))
#+end_src

** Books

I prefer to read ebooks because being able to highlight and copy text from the book makes it much easier to take notes. Emacs has a great system for reading and annotating PDF files ([[https://github.com/politza/pdf-tools][pdf-tools]]). I store all of my ebooks in a single flat directory. Metadata about each book is stored in a [[http://www.bibtex.org/][Bibtex]] file and each books is named after it's bibtex entry ID.

- Note :: [[https://books.google.com/][books.google.com]] provides bibtex-style citations for books in it's database

I use [[https://github.com/weirdNox/org-noter][org-noter]] when I'm taking notes on the book. It provides an interface with the PDF and the org-mode notes side-by-side. Org-noter will add metadata to your notes to link them to the page in the PDF that they're about


*** org-noter
#+begin_src elisp :noweb-ref configs :results none
(setq org-noter-always-create-frame nil
      org-noter-notes-search-path '("~/roam/books")
      org-noter-doc-split-percentage '(0.67 . 0.33)
                )

(undefine-key! pdf-view-mode-map :n "i")
(map! :after org-noter
      :mode org-noter-doc-mode
      :n "i" #'org-noter-insert-note)
#+end_src

#+begin_src elisp :noweb-ref packages
(package! org-noter-pdftools)
#+end_src

*** Bibtex
#+begin_src elisp :noweb-ref configs
(defvar ccc/books-dir "~/roam/books")
(after! citar
    (setq
            citar-bibliography '("~/roam/books/books.bib")
            citar-library-paths '("~/roam/books/")
            citar-notes-paths '("~/roam/books/")
            citar-default-action #'citar-open-files
            org-ref-default-bibliography '("~/roam/books/books.bib")
            reftex-default-bibliography org-ref-default-bibliography
            org-ref-pdf-directory "~/roam/books/"
            bibtex-completion-notes-template-multiple-files "#+TITLE: ${title}
    ,#+ROAM_KEY: cite:${=key=}

    - tags :: %?"
                    )

    (defun bibtex-add-entry (entry)
    (let* ((id (with-temp-buffer
                    (bibtex-mode)
                    (insert entry)
                    (bibtex-completion-key-at-point)))
            (exists (citar-get-entry id)))
        (if exists
            (message (format "Entry %s already exists" id))
        (with-current-buffer (find-file-noselect (car citar-bibliography))
            (end-of-buffer)
            (insert "\n" entry)
            (save-buffer)))))
  )

(defun ccc/add-book (file citekey)
  (interactive (list (read-file-name "Add file: ") (citar-select-ref)))
  (let ((new-path (format "%s/%s.%s" ccc/books-dir citekey (f-ext file))))
    (copy-file file new-path)))

(map! :leader
      "o B" #'citar-open-files)
(map! :map embark-file-map
      "b" #'ccc/add-book)
#+end_src

#+begin_src elisp :noweb-ref packages
(package! org-roam-bibtex)
(package! org-ref)
#+end_src

*** google-books
#+begin_src elisp :noweb-ref configs
(defun google-books--get-bibtex (book)
  "Get a bibtex file from Google Books API"
  ;; book
  (url-to-string (format "https://books.google.com/books?id=%s&output=bibtex" book))
  )

(defun google-books--search (pattern)
  "Search Google Books API"
  (interactive)
  (let* ((url (browse-url-encode-url (concat "https://www.googleapis.com/books/v1/volumes?q=" pattern)))
        (response (url-to-string url)))
    (cdr (nth 2 (json-read-from-string response)))))

(defun google-books--builder (prompt)
  `( "/home/chaise/dotfiles/bin/curl-jq.sh"
     ,(browse-url-encode-url (concat "https://www.googleapis.com/books/v1/volumes?q=" prompt))
     ".items[]")
  )

(defun google-books--display-candidate (candidate)
  (let ((json (json-parse-string candidate)))
    (list (gethash "title" (gethash "volumeInfo" json)) (gethash "id" json)))
  )

(defun google-books--lookup (selected candidates &rest _)
  (nth 1 (assoc selected candidates)))

  (defun google-books--read-title ()
    (consult--read (consult--async-command #'google-books--builder (consult--async-map #'google-books--display-candidate))
     :prompt "Title"
     :lookup #'google-books--lookup
     :initial (consult--async-split-initial nil)
     :require-match t
     )
    )

(defun google-books ()
    "Books searcher with ivy interface."
    (interactive)
    (let ((book (google-books--read-title)))
      (bibtex-add-entry (google-books--get-bibtex book))
      )
)
#+end_src

*** pdf-tools
| Command                                   | Key       | Description             |
|-------------------------------------------+-----------+-------------------------|
| pdf-view-goto-page                        | g p       |                         |
| pdf-view-midnight-minor-mode              | z m       | Dark mode               |
| pdf-view-fit-height-to-window             | H         |                         |
| pdf-view-fit-width-to-window              | W         |                         |
| pdf-annot-add-highlight-markup-annotation | C-c C-a h | Highlight selected text |
| pdf-annot-list-annotations                | C-c C-a l | List all annotations    |

#+begin_src elisp :noweb-ref configs
(map! :after pdf-tools
      :mode pdf-view-mode
      :n "g p" #'pdf-view-goto-page
      )
#+end_src
*** Capture

Used to capture books I want to read into the right category

#+begin_src elisp :noweb-ref capture-templates
("Book" :keys "b" :function (lambda () (goto-or-create-heading "Books"))
    :book (lambda () (citar-select-ref))
    :template-file "~/roam/areas/org/templates/book.org")
#+end_src
** Tasks

- [ ] Increase speed somehow
  - Skip direct links and deviantart
  - Run items in parallel?
- [ ] Maybe write metadata files so I can get links to the posts
- [ ] Add instgrams and twitters

#+begin_src elisp :noweb-ref configs
(defvar task-queue nil)

(defvar task-current nil)

(defvar images-file "~/roam/other/images.org")

(defvar download-command
  "/home/chaise/.local/bin/gallery-dl --dest /home/chaise/gallery-dl --verbose --filter 'date > datetime.utcfromtimestamp(%d)' -A 2 %s")

(defun queue-task (cmd)
  (interactive)
  (if task-current
      (setq task-queue (append task-queue (list cmd)))
      (start-task cmd))
  task-queue)

(defun next-task ()
  (interactive)
  (when task-queue
    (start-task (car task-queue)))
    (setq task-queue (cdr task-queue)))

(defun yesterday-start ()
  (let ((yesterday (decode-time (time-add (current-time) (* 3600 -24)))))
    (time-convert
     (encode-time (make-decoded-time :second 0 :minute 0 :hour 0 :day (nth 3 yesterday) :month (nth 4 yesterday) :year (nth 5 yesterday)))
     'integer)
    ))

(defun start-task (cmd)
  (interactive)
  (let* ((default-directory "/home/chaise")
         (process (start-process-shell-command "task" "*tasks*" cmd)))
    (setq task-current cmd)
    (set-process-sentinel process (lambda (process event) (setq task-current nil) (next-task)))
    ))

(defun download-images ()
  (interactive)
  (dolist (link (image-links))
    (let ((cmd (format download-command (yesterday-start) link)))
      (queue-task cmd))
    )
  )

(defun image-links ()
  (with-current-buffer
      (find-file-noselect images-file)
(-non-nil (org-map-entries
   (lambda ()
        (forward-char 3)
     (let ((hyperlink (s-match "^\\[\\[\\(http.+?\\)\\]\\(?:\\[.+?\\]\\)?\\]" (org-get-heading))))
       (when hyperlink
         (nth 1 hyperlink)
       )
       ))))
      )
  )
#+end_src
** Agenda  :crypt:

-----BEGIN PGP MESSAGE-----

hQEMAwdIIsOCIXDtAQf/RdSce6Xe+Km8A8qseoOWBswTCGC95vVLfSZ1+3YecRb0
//YVK4X0c9CA9p8BpI3njhZ8VYJCOZuhqJ9yOL67QaW7ebaOl9JC8F5wbXBaa8Ty
xa4g5P/i3TaB/yXIFVxLdWAT1+OQb/kaKqYZzY7PHHXr1fBVA+IjTTB3QxaIAnOS
dt7nEmHz2ugLLQBOK1M3m7iPddB3LbpLeNKlVDMHu06paR8Ms00KDStjp5JMMqjO
ioQzZ9K+CrwkdG05EvTyhw0hM+crN5mQ0GQpKOMTWlrtNzWmeEVuOXMyYljh6Nl+
LjByStEsAeTvTbTOa+6offmFRolvAyzQRYCY/H/cstLAlwGI865TvkRvS2APYzU2
BXJ8Cp5/nET/Qn5YPc2lXDbGAn1kRmFaVksSLx81vYvA/8xWPN1krMS0AhfhvJeN
aC/kNeUX+JNfn1oBiAaPpnb2VbmbDjeTa7fnzs2Re7kErfptC6ktv9SYVHCZ/mC0
jQL2wy8NnuZHuisFl/GbfEOUbS0HEGrKcjlKhkoOf9PlTQMEIyAmGJTNej1QQKJP
qde1nXOvXVyMb5bdvR1qeJi1jquWJwGtpGBLOzrPVMRYJ3bKFJpmeRvERPHvyIGH
8FSSgtMvIQt9pvZ0S8wmxnMZgz7fTIP28Kn8x8Fgbb/rgSuFrgnoiJu1Ak4AJWiJ
0sMNcoPhqytH29oJklZ06Tz2oZ3Bp3EUvpTpbX1tQMz84R+i/vnsI8DYspw5mKNw
DIHCtFaVJoLv5A8EVk3DGgV3RmHGAk1AVT0qbN+13eMlXh0At20TwmI=
=pxq9
-----END PGP MESSAGE-----
